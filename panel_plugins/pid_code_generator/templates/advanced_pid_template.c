/**
 * @file    {{FUNCTION_PREFIX}}_pid.c (Example, actual name from generator config)
 * @author  YJ Studio Team (Generated by Advanced PID Code Generator)
 * @version 2.0.0
 * @date    {{TIMESTAMP}}
 * @brief   Advanced PID Controller Library Implementation File.
 *
 * @details This file implements the functions for an advanced PID controller
 * as declared in {{HEADER_NAME}}.
 *
 * @note    This is a template file. Placeholders like {{DATA_TYPE}},
 * {{STRUCT_NAME}}, {{FUNCTION_PREFIX}}, and {{*_DEFAULT}} values
 * will be replaced during code generation.
 */

#include "{{HEADER_NAME}}" // This will be replaced, e.g., "pid.h"
#include <math.h>          // For fabsf, INFINITY (if not defined in header)
#include <stddef.h>        // For NULL

#ifndef INFINITY
    /** @brief Definition of infinity if not already defined. */
    #define INFINITY (1.0f/0.0f)
#endif

/**
 * @brief Constrains a value within a specified minimum and maximum range.
 * @param[in] value The value to constrain.
 * @param[in] min   The minimum allowed value.
 * @param[in] max   The maximum allowed value.
 * @return The constrained value.
 */
static inline {{DATA_TYPE}} constrain_pid_output({{DATA_TYPE}} value, {{DATA_TYPE}} min_val, {{DATA_TYPE}} max_val) {
    if (value < min_val) return min_val;
    if (value > max_val) return max_val;
    return value;
}


/**
 * @brief Initializes the PID controller structure.
 * @see {{FUNCTION_PREFIX}}_Init in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_Init({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kp_continuous, {{DATA_TYPE}} Ki_continuous, {{DATA_TYPE}} Kd_continuous, {{DATA_TYPE}} sample_time_val) {
    if (pid == NULL) return;

    pid->Kp = Kp_continuous;
    // Ensure sample_time_val is positive to prevent division by zero or negative gains
    if (sample_time_val > 0.000001f) {
        pid->Ki = Ki_continuous * sample_time_val; // Convert continuous Ki to discrete
        pid->Kd = Kd_continuous / sample_time_val; // Convert continuous Kd to discrete
    } else {
        // Fallback if sample_time_val is invalid, though ideally an error should be flagged
        pid->Ki = Ki_continuous; 
        pid->Kd = Kd_continuous; 
    }
    pid->sample_time = (sample_time_val > 0.000001f) ? sample_time_val : 0.01f; // Default to 0.01 if invalid

    // Initialize ALL other members to library defaults specified by generator
    pid->Kff = {{KFF_DEFAULT}};
    pid->ff_weight = {{FF_WEIGHT_DEFAULT}}; 

    pid->output_limit = {{OUTPUT_LIMIT_DEFAULT}}; 
    pid->integral_limit = {{INTEGRAL_LIMIT_DEFAULT}};  
    pid->output_ramp = {{OUTPUT_RAMP_DEFAULT}};      
    pid->deadband = {{DEADBAND_DEFAULT}};         
    pid->integral_separation_threshold = {{INTEGRAL_SEPARATION_THRESHOLD_DEFAULT}}; 

    pid->d_filter_coef = {{D_FILTER_COEF_DEFAULT}};    
    pid->input_filter_coef = {{INPUT_FILTER_COEF_DEFAULT}};  
    pid->setpoint_filter_coef = {{SETPOINT_FILTER_COEF_DEFAULT}}; 

    // Initialize state variables by calling Reset
    {{FUNCTION_PREFIX}}_Reset(pid); 

    // Default operational modes
    pid->mode = PID_MODE_AUTOMATIC;
    pid->type = PID_TYPE_STANDARD;
    pid->work_mode = PID_MODE_POSITION;
}

/**
 * @brief Sets new PID tuning parameters.
 * @see {{FUNCTION_PREFIX}}_SetTunings in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetTunings({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kp_continuous, {{DATA_TYPE}} Ki_continuous, {{DATA_TYPE}} Kd_continuous) {
    if (pid == NULL) return;
    // Basic validation for gains
    if (Kp_continuous < 0.0f || Ki_continuous < 0.0f || Kd_continuous < 0.0f) return; 

    pid->Kp = Kp_continuous;
    if (pid->sample_time > 0.000001f) {
        pid->Ki = Ki_continuous * pid->sample_time;
        pid->Kd = Kd_continuous / pid->sample_time;
    } else {
        // Fallback if sample_time is not properly set (should not happen if Init was called)
        pid->Ki = Ki_continuous; 
        pid->Kd = Kd_continuous;
    }
}

/**
 * @brief Sets feedforward parameters.
 * @see {{FUNCTION_PREFIX}}_SetFeedForwardParams in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetFeedForwardParams({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kff, {{DATA_TYPE}} ff_weight) {
    if (pid == NULL) return;
    pid->Kff = Kff;
    pid->ff_weight = constrain_pid_output(ff_weight, 0.0f, 1.0f);
}

/**
 * @brief Sets the controller sample time.
 * @see {{FUNCTION_PREFIX}}_SetSampleTime in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetSampleTime({{STRUCT_NAME}} *pid, {{DATA_TYPE}} sample_time_new) {
    if (pid == NULL || sample_time_new <= 0.000001f) return;

    // If sample time changes significantly, recalculate discrete Ki and Kd
    if (pid->sample_time > 0.000001f && fabsf(pid->sample_time - sample_time_new) > 0.0000001f) {
        // Convert Ki and Kd back to continuous domain using old sample time
        {{DATA_TYPE}} ki_continuous = pid->Ki / pid->sample_time;
        {{DATA_TYPE}} kd_continuous = pid->Kd * pid->sample_time;
        // Convert to discrete domain using new sample time
        pid->Ki = ki_continuous * sample_time_new;
        pid->Kd = kd_continuous / sample_time_new;
    }
    pid->sample_time = sample_time_new;
}

/**
 * @brief Sets the absolute output limits.
 * @see {{FUNCTION_PREFIX}}_SetOutputLimits in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetOutputLimits({{STRUCT_NAME}} *pid, {{DATA_TYPE}} limit) {
    if (pid == NULL) return;
    pid->output_limit = fabsf(limit); // Store as positive, apply as +/- limit
}

/**
 * @brief Sets the absolute integral limits.
 * @see {{FUNCTION_PREFIX}}_SetIntegralLimits in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetIntegralLimits({{STRUCT_NAME}} *pid, {{DATA_TYPE}} limit) {
    if (pid == NULL) return;
    pid->integral_limit = fabsf(limit); // Store as positive
}

/**
 * @brief Sets the output ramp rate.
 * @see {{FUNCTION_PREFIX}}_SetOutputRamp in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetOutputRamp({{STRUCT_NAME}} *pid, {{DATA_TYPE}} rate) {
    if (pid == NULL) return;
    pid->output_ramp = fabsf(rate); // Rate is positive
}

/**
 * @brief Sets the error deadband.
 * @see {{FUNCTION_PREFIX}}_SetDeadband in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetDeadband({{STRUCT_NAME}} *pid, {{DATA_TYPE}} deadband_val) {
    if (pid == NULL) return;
    pid->deadband = fabsf(deadband_val);
}

/**
 * @brief Sets the integral separation threshold.
 * @see {{FUNCTION_PREFIX}}_SetIntegralSeparationThreshold in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetIntegralSeparationThreshold({{STRUCT_NAME}} *pid, {{DATA_TYPE}} threshold) {
    if (pid == NULL) return;
    pid->integral_separation_threshold = fabsf(threshold);
}

/**
 * @brief Sets the D-term filter coefficient.
 * @see {{FUNCTION_PREFIX}}_SetDFilter in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetDFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef) {
    if (pid == NULL) return;
    pid->d_filter_coef = constrain_pid_output(filter_coef, 0.0f, 1.0f);
}

/**
 * @brief Sets the input filter coefficient.
 * @see {{FUNCTION_PREFIX}}_SetInputFilter in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetInputFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef) {
    if (pid == NULL) return;
    pid->input_filter_coef = constrain_pid_output(filter_coef, 0.0f, 1.0f);
}

/**
 * @brief Sets the setpoint filter coefficient.
 * @see {{FUNCTION_PREFIX}}_SetSetpointFilter in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetSetpointFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef) {
    if (pid == NULL) return;
    pid->setpoint_filter_coef = constrain_pid_output(filter_coef, 0.0f, 1.0f);
}

/**
 * @brief Sets the PID controller mode.
 * @see {{FUNCTION_PREFIX}}_SetMode in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetMode({{STRUCT_NAME}} *pid, PID_ModeType mode) {
    if (pid == NULL) return;
    // Optional: Implement bumpless transfer logic if mode changes
    // For example, if switching from MANUAL to AUTOMATIC, set integral to current output contribution
    // if (pid->mode == PID_MODE_MANUAL && mode == PID_MODE_AUTOMATIC && pid->Ki != 0.0f) {
    //    pid->integral = pid->output / pid->Ki; // Simplified, assumes output was from I-term mainly
    //    pid->integral = constrain_pid_output(pid->integral, -pid->integral_limit, pid->integral_limit);
    // }
    pid->mode = mode;
}

/**
 * @brief Sets the PID calculation type.
 * @see {{FUNCTION_PREFIX}}_SetType in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetType({{STRUCT_NAME}} *pid, PID_Type type) {
    if (pid == NULL) return;
    pid->type = type;
}

/**
 * @brief Sets the PID work mode (output type).
 * @see {{FUNCTION_PREFIX}}_SetWorkMode in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetWorkMode({{STRUCT_NAME}} *pid, PID_WorkMode work_mode) {
    if (pid == NULL) return;
    pid->work_mode = work_mode;
}

/**
 * @brief Computes the PID output.
 * @see {{FUNCTION_PREFIX}}_Compute in {{HEADER_NAME}} for detailed parameter descriptions.
 */
{{DATA_TYPE}} {{FUNCTION_PREFIX}}_Compute({{STRUCT_NAME}} *pid, {{DATA_TYPE}} setpoint, {{DATA_TYPE}} measure) {
    if (pid == NULL) return 0.0f; // Or some error code/value
    if (pid->sample_time <= 0.000001f) return pid->output; // Avoid division by zero if sample time is invalid

    // If in manual mode, return the manually set output
    if (pid->mode == PID_MODE_MANUAL) {
        return pid->output;
    }

    // Apply input filtering to measurement
    if (pid->input_filter_coef > 0.0f && pid->input_filter_coef < 1.0f) {
        pid->filtered_measure = pid->filtered_measure * (1.0f - pid->input_filter_coef) +
                                measure * pid->input_filter_coef;
        measure = pid->filtered_measure; // Use filtered measurement for calculations
    } else {
        pid->filtered_measure = measure; // No filtering or invalid coefficient
    }

    // Apply setpoint filtering
    if (pid->setpoint_filter_coef > 0.0f && pid->setpoint_filter_coef < 1.0f) {
        pid->filtered_setpoint = pid->filtered_setpoint * (1.0f - pid->setpoint_filter_coef) +
                                 setpoint * pid->setpoint_filter_coef;
        setpoint = pid->filtered_setpoint; // Use filtered setpoint
    } else {
        pid->filtered_setpoint = setpoint;
    }

    // Calculate error
    {{DATA_TYPE}} error = setpoint - measure;

    // Apply deadband: if error is within deadband, treat as zero
    if (pid->deadband > 0.0f && fabsf(error) < pid->deadband) {
        error = 0.0f;
    }

    // --- Proportional Term ---
    {{DATA_TYPE}} p_term;
    if (pid->type == PID_TYPE_STANDARD || pid->type == PID_TYPE_PI_D) {
        p_term = pid->Kp * error; // P on Error
    } else { // PID_TYPE_I_PD
        p_term = -pid->Kp * (measure - pid->prev_measure); // P on Measurement (change)
                                                           // or simply -pid->Kp * measure; (absolute)
                                                           // Using change is common for P-on-M
                                                           // This might need clarification based on desired I-PD behavior.
                                                           // For simplicity, let's use: -pid->Kp * measure
        p_term = -pid->Kp * measure; // P on Measurement (absolute value, negative contribution for typical setup)
                                     // If using P on delta_measure, it becomes part of D-term.
                                     // A common I-PD is I(error) - P(measure) - D(measure).
                                     // Let's assume P on Error for PI-D, and P on Measurement for I-PD.
                                     // The most common I-PD form is P(error_deriv) and D(error_deriv) on measurement.
                                     // Reverting p_term for I_PD to be on error, as I-PD usually modifies D and P relative to measurement.
                                     // The definition of I-PD in the enum (P based on measure) is tricky.
                                     // Let's assume for I-PD: P_term = - Kp * measure_filtered
                                     // No, common I-PD is P=Kp*error, D=-Kd*(meas-prev_meas)/Ts.
                                     // Okay, let's stick to P on error for STANDARD and PI_D. For I_PD: P is on -measurement.
        if(pid->type == PID_TYPE_I_PD) p_term = -pid->Kp * measure; // P on measurement (negative for stability)
        else p_term = pid->Kp * error; // P on error for STANDARD, PI_D
    }


    // --- Integral Term ---
    // Integral action only if error is below separation threshold
    if (fabsf(error) < pid->integral_separation_threshold) {
        pid->integral += pid->Ki * error;
        // Anti-windup: Clamp integral term
        pid->integral = constrain_pid_output(pid->integral, -pid->integral_limit, pid->integral_limit);
    }
    // {{DATA_TYPE}} i_term = pid->integral; // Using pid->integral directly is fine

    // --- Derivative Term ---
    {{DATA_TYPE}} derivative_input;
    if (pid->type == PID_TYPE_STANDARD) {
        derivative_input = (error - pid->prev_error); // D on Error
    } else { // PID_TYPE_PI_D or PID_TYPE_I_PD
        derivative_input = -(measure - pid->prev_measure); // D on Measurement (negative due to (pv-pv_prev))
    }
    derivative_input /= pid->sample_time;

    // Apply derivative low-pass filter
    if (pid->d_filter_coef > 0.0f && pid->d_filter_coef < 1.0f) {
        pid->filtered_d = pid->filtered_d * (1.0f - pid->d_filter_coef) +
                          derivative_input * pid->d_filter_coef;
    } else {
        pid->filtered_d = derivative_input; // No filtering or invalid coefficient
    }
    {{DATA_TYPE}} d_term = pid->Kd * pid->filtered_d;

    // --- Feedforward Term ---
    // Typically, feedforward is based on the setpoint
    pid->last_ff_term = pid->Kff * setpoint * pid->ff_weight;

    // --- Total Output Calculation ---
    {{DATA_TYPE}} computed_output = p_term + pid->integral + d_term + pid->last_ff_term;

    // Apply output rate limiting (ramp control)
    if (pid->output_ramp > 0.0f) {
        {{DATA_TYPE}} max_change_this_cycle = pid->output_ramp * pid->sample_time;
        {{DATA_TYPE}} change_in_output = computed_output - pid->prev_output; // prev_output is actual previous output
        change_in_output = constrain_pid_output(change_in_output, -max_change_this_cycle, max_change_this_cycle);
        computed_output = pid->prev_output + change_in_output;
    }

    // Apply output saturation
    computed_output = constrain_pid_output(computed_output, -pid->output_limit, pid->output_limit);

    // --- Update State for Next Iteration ---
    pid->prev_error = error;
    pid->prev_measure = measure; // Store the (possibly filtered) measurement used
    pid->prev_setpoint = setpoint; // Store the (possibly filtered) setpoint used

    // Handle velocity mode output
    if (pid->work_mode == PID_MODE_VELOCITY) {
        pid->output = computed_output - pid->prev_output; // Output is the increment
        pid->prev_output = computed_output; // Update prev_output to the new absolute level
    } else { // PID_MODE_POSITION
        pid->output = computed_output;
        pid->prev_output = computed_output;
    }
    
    pid->last_p_term = p_term; // Store for debugging

    return pid->output;
}

/**
 * @brief Computes PID output with dynamic sample time based on current time.
 * @see {{FUNCTION_PREFIX}}_ComputeWithTime in {{HEADER_NAME}} for detailed parameter descriptions.
 */
{{DATA_TYPE}} {{FUNCTION_PREFIX}}_ComputeWithTime({{STRUCT_NAME}} *pid, {{DATA_TYPE}} setpoint, {{DATA_TYPE}} measure, uint32_t current_time_ms) {
    if (pid == NULL) return 0.0f;

    if (pid->last_time == 0) { // First call after Init/Reset
        pid->last_time = current_time_ms;
        // Reset internal states that depend on first measurement/error
        pid->prev_measure = measure; 
        pid->prev_error = setpoint - measure;
        pid->filtered_measure = measure;
        pid->filtered_setpoint = setpoint;
        // Initial output might be based on P and FF, or zero. For simplicity, compute normally.
    }

    uint32_t elapsed_ms = current_time_ms - pid->last_time;
    if (elapsed_ms == 0 && pid->last_time != 0) { // No time elapsed, or timer wrap-around not handled yet
        // Avoid computation if no time passed to prevent division by zero or stale output
        // return pid->output; // This might be problematic if output hasn't been computed yet.
    }
    
    {{DATA_TYPE}} dt_seconds = ({{DATA_TYPE}})elapsed_ms / 1000.0f;

    // Store original Ki, Kd, and sample_time
    {{DATA_TYPE}} original_Ki = pid->Ki;
    {{DATA_TYPE}} original_Kd = pid->Kd;
    {{DATA_TYPE}} original_sample_time = pid->sample_time;

    // Temporarily adjust discrete gains for this specific delta_time
    // This requires Ki and Kd to be thought of in their continuous forms when Init/SetTunings was called.
    // If pid->Ki and pid->Kd are already discrete (Ki_cont * Ts_orig, Kd_cont / Ts_orig)
    // Then Ki_new = (pid->Ki / Ts_orig) * dt_seconds
    // And Kd_new = (pid->Kd * Ts_orig) / dt_seconds
    if (original_sample_time > 0.000001f && dt_seconds > 0.000001f) {
        pid->Ki = (original_Ki / original_sample_time) * dt_seconds;
        pid->Kd = (original_Kd * original_sample_time) / dt_seconds; // This seems off: Kd_discrete = Kd_cont / Ts. Kd_cont = Kd_discrete * Ts. Kd_new_discrete = Kd_cont / dt_seconds
                                                                 // Kd_new_discrete = (original_Kd * original_sample_time) / dt_seconds
        pid->sample_time = dt_seconds;
    } else if (dt_seconds <= 0.000001f) { // No time or very small time elapsed
         return pid->output; // Return previous output
    }
    // If original_sample_time was invalid, gains might be incorrect; Init should prevent this.

    {{DATA_TYPE}} result = {{FUNCTION_PREFIX}}_Compute(pid, setpoint, measure);

    // Restore original discrete gains and sample_time for subsequent fixed-interval calls or SetTunings
    pid->Ki = original_Ki;
    pid->Kd = original_Kd;
    pid->sample_time = original_sample_time;
    
    pid->last_time = current_time_ms;

    return result;
}


/**
 * @brief Resets the PID controller's internal state.
 * @see {{FUNCTION_PREFIX}}_Reset in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_Reset({{STRUCT_NAME}} *pid) {
    if (pid == NULL) return;

    pid->integral         = 0.0f;
    pid->prev_error       = 0.0f;
    pid->prev_prev_error  = 0.0f; // If used by specific logic
    pid->prev_measure     = 0.0f; // Or initialize to current measurement if available
    pid->prev_prev_measure= 0.0f; // If used
    pid->prev_output      = 0.0f;
    pid->prev_setpoint    = 0.0f; // Or initialize to current setpoint if available

    pid->filtered_d       = 0.0f;
    pid->filtered_measure = 0.0f; // Reset filtered values
    pid->filtered_setpoint= 0.0f;

    pid->output           = 0.0f; // Current output reset

    pid->last_time        = 0;    // Reset for ComputeWithTime

    // Debug terms
    pid->last_p_term      = 0.0f;
    pid->last_ff_term     = 0.0f;
}

/**
 * @brief Manually sets the PID output value.
 * @see {{FUNCTION_PREFIX}}_SetOutput in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_SetOutput({{STRUCT_NAME}} *pid, {{DATA_TYPE}} output_val) {
    if (pid == NULL) return;
    // This function should only take effect if in manual mode
    if (pid->mode == PID_MODE_MANUAL) {
        pid->output = constrain_pid_output(output_val, -pid->output_limit, pid->output_limit);
        // When output is set manually, prev_output should also reflect this for ramp limiting if mode changes
        pid->prev_output = pid->output; 
    }
}

/**
 * @brief Retrieves the last computed PID components.
 * @see {{FUNCTION_PREFIX}}_GetComponents in {{HEADER_NAME}} for detailed parameter descriptions.
 */
void {{FUNCTION_PREFIX}}_GetComponents({{STRUCT_NAME}} *pid, {{DATA_TYPE}} *p_term, {{DATA_TYPE}} *i_term, {{DATA_TYPE}} *d_term, {{DATA_TYPE}} *ff_term) {
    if (pid == NULL) return;

    if (p_term != NULL) {
        *p_term = pid->last_p_term;
    }
    if (i_term != NULL) {
        *i_term = pid->integral; // Current integral value
    }
    if (d_term != NULL) {
        // d_term is typically Kd * filtered_derivative_input. pid->filtered_d stores the derivative_input after filtering.
        // So, the actual d_term would be pid->Kd * pid->filtered_d
        *d_term = pid->Kd * pid->filtered_d; 
    }
    if (ff_term != NULL) {
        *ff_term = pid->last_ff_term;
    }
}