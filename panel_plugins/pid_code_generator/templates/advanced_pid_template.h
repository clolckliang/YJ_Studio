/**
 * @file    {{HEADER_NAME}}
 * @author  YJ Studio Team (Generated by Advanced PID Code Generator)
 * @version 2.0.0
 * @date    {{TIMESTAMP}}
 * @brief   Advanced PID Controller Library Header File.
 *
 * @details This file contains the type definitions, structure definitions,
 * and function declarations for an advanced PID controller.
 * It supports various PID types, modes, and advanced features
 * like filtering, feedforward, and output ramping.
 *
 * @note    This is a template file. Placeholders like {{DATA_TYPE}},
 * {{STRUCT_NAME}}, and {{FUNCTION_PREFIX}} will be replaced
 * during code generation.
 */

#ifndef __PID_H_ADVANCED_TEMPLATE__ // Using a more unique guard
#define __PID_H_ADVANCED_TEMPLATE__

#include <stdint.h>
#include <stdbool.h>
#include <math.h>

#ifndef INFINITY
    /** @brief Definition of infinity if not already defined. */
    #define INFINITY (1.0f/0.0f)
#endif

/**
 * @brief PID Controller Mode Enumeration.
 * @details Defines whether the PID controller is operating in manual or automatic mode.
 */
typedef enum {
    PID_MODE_MANUAL    = 0, /**< Manual mode: Output is set directly by the user. */
    PID_MODE_AUTOMATIC = 1  /**< Automatic mode: Output is calculated by the PID algorithm. */
} PID_ModeType;

/**
 * @brief PID Controller Type Enumeration.
 * @details Defines how Proportional, Integral, and Derivative terms are calculated
 * relative to the error or process variable (measurement).
 */
typedef enum {
    PID_TYPE_STANDARD = 0,  /**< Standard PID: P and D terms are based on error (Setpoint - Measurement). */
    PID_TYPE_PI_D     = 1,  /**< PI-D Type: P term on error, D term on measurement. Helps with setpoint changes. */
    PID_TYPE_I_PD     = 2   /**< I-PD Type: I term on error, P and D terms on measurement. Further reduces setpoint kick. */
} PID_Type;

/**
 * @brief PID Controller Work Mode Enumeration.
 * @details Defines the nature of the PID controller's output.
 */
typedef enum {
    PID_MODE_POSITION = 0,  /**< Positional Mode: Output is an absolute control value. */
    PID_MODE_VELOCITY = 1   /**< Velocity (Incremental) Mode: Output is the change in control value. */
} PID_WorkMode;

/**
 * @brief PID Controller Handle Structure.
 * @details This structure holds all parameters, state variables, and configurations
 * for a single PID controller instance.
 */
typedef struct {
    /* Controller Gains & Coefficients */
    {{DATA_TYPE}} Kp;               /**< Proportional gain. */
    {{DATA_TYPE}} Ki;               /**< Integral gain (discrete form: Ki_continuous * SampleTime). */
    {{DATA_TYPE}} Kd;               /**< Derivative gain (discrete form: Kd_continuous / SampleTime). */
    {{DATA_TYPE}} Kff;              /**< Feedforward gain. */
    {{DATA_TYPE}} ff_weight;        /**< Feedforward term weight (0.0 to 1.0). */

    /* Operational Limits & Thresholds */
    {{DATA_TYPE}} output_limit;     /**< Absolute limit for the controller output (e.g., if 100, output is +/-100). */
    {{DATA_TYPE}} integral_limit;   /**< Absolute limit for the integral accumulator. */
    {{DATA_TYPE}} output_ramp;      /**< Maximum rate of change for the output (units per second). 0 for no limit. */
    {{DATA_TYPE}} deadband;         /**< Error deadband range (error values within +/- deadband/2 are treated as zero). */
    {{DATA_TYPE}} integral_separation_threshold; /**< Absolute error threshold below which integral action is active. */

    /* Filter Coefficients (0.0 to 1.0, typically a small value like 0.1 for filtering) */
    {{DATA_TYPE}} d_filter_coef;    /**< Low-pass filter coefficient for the derivative term. 0 for no filter. */
    {{DATA_TYPE}} input_filter_coef;/**< Low-pass filter coefficient for the measurement input. 0 for no filter. */
    {{DATA_TYPE}} setpoint_filter_coef; /**< Low-pass filter coefficient for the setpoint. 0 for no filter. */

    /* State Variables - Internal use, typically not modified directly */
    {{DATA_TYPE}} integral;         /**< Integral accumulator value. */
    {{DATA_TYPE}} prev_error;       /**< Error from the previous computation cycle. */
    {{DATA_TYPE}} prev_prev_error;  /**< Error from two computation cycles ago (for some algorithms). */
    {{DATA_TYPE}} prev_measure;     /**< Measurement from the previous computation cycle. */
    {{DATA_TYPE}} prev_prev_measure;/**< Measurement from two cycles ago. */
    {{DATA_TYPE}} prev_output;      /**< Output from the previous computation cycle. */
    {{DATA_TYPE}} prev_setpoint;    /**< Setpoint from the previous computation cycle. */
    {{DATA_TYPE}} filtered_d;       /**< Filtered derivative value. */
    {{DATA_TYPE}} filtered_measure; /**< Filtered measurement value. */
    {{DATA_TYPE}} filtered_setpoint;/**< Filtered setpoint value. */
    {{DATA_TYPE}} output;           /**< Current controller output value. */

    /* Timing Variables */
    {{DATA_TYPE}} sample_time;      /**< Controller sample time in seconds. */
    uint32_t      last_time;        /**< Timestamp of the last computation (milliseconds, for dynamic sample time). */

    /* Controller Configuration */
    PID_ModeType mode;              /**< Current operational mode (Manual/Automatic). @see PID_ModeType */
    PID_Type     type;              /**< PID calculation type (Standard, PI-D, I-PD). @see PID_Type */
    PID_WorkMode work_mode;         /**< PID output type (Positional/Velocity). @see PID_WorkMode */

    /* Debugging Information - Read-only from user perspective */
    {{DATA_TYPE}} last_p_term;      /**< Proportional term from the last computation. */
    {{DATA_TYPE}} last_ff_term;     /**< Feedforward term from the last computation. */

} {{STRUCT_NAME}};

/* --- Public Function Declarations --- */

/**
 * @brief Initializes the PID controller structure with specified gains and sample time.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance to initialize.
 * @param[in]     Kp_continuous Proportional gain (continuous domain).
 * @param[in]     Ki_continuous Integral gain (continuous domain).
 * @param[in]     Kd_continuous Derivative gain (continuous domain).
 * @param[in]     sample_time_val Controller sample time in seconds.
 * @note          This function sets all other parameters to sensible library defaults.
 * Use specific SetXxx functions to override these defaults.
 * Ki and Kd are converted to their discrete forms internally.
 */
void {{FUNCTION_PREFIX}}_Init({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kp_continuous, {{DATA_TYPE}} Ki_continuous, {{DATA_TYPE}} Kd_continuous, {{DATA_TYPE}} sample_time_val);

/**
 * @brief Sets new PID tuning parameters (Kp, Ki, Kd).
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     Kp_continuous New proportional gain (continuous domain).
 * @param[in]     Ki_continuous New integral gain (continuous domain).
 * @param[in]     Kd_continuous New derivative gain (continuous domain).
 * @note          Gains must be non-negative. Internal Ki and Kd are updated based on current sample time.
 */
void {{FUNCTION_PREFIX}}_SetTunings({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kp_continuous, {{DATA_TYPE}} Ki_continuous, {{DATA_TYPE}} Kd_continuous);

/**
 * @brief Sets feedforward parameters.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     Kff New feedforward gain.
 * @param[in]     ff_weight New feedforward weight (0.0 to 1.0).
 */
void {{FUNCTION_PREFIX}}_SetFeedForwardParams({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kff, {{DATA_TYPE}} ff_weight);

/**
 * @brief Sets the controller sample time in seconds.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     sample_time_new New sample time in seconds (must be > 0).
 * @note          Adjusts discrete Ki and Kd gains based on the new sample time.
 */
void {{FUNCTION_PREFIX}}_SetSampleTime({{STRUCT_NAME}} *pid, {{DATA_TYPE}} sample_time_new);

/**
 * @brief Sets the absolute output limits for the controller. Output will be clamped to +/- limit.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     limit The absolute maximum value for the output.
 */
void {{FUNCTION_PREFIX}}_SetOutputLimits({{STRUCT_NAME}} *pid, {{DATA_TYPE}} limit);

/**
 * @brief Sets the absolute limits for the integral accumulator. Integral sum will be clamped to +/- limit.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     limit The absolute maximum value for the integral term.
 */
void {{FUNCTION_PREFIX}}_SetIntegralLimits({{STRUCT_NAME}} *pid, {{DATA_TYPE}} limit);

/**
 * @brief Sets the maximum output change rate (units per second).
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     rate Maximum change per second. Set to 0 for no ramp limiting.
 */
void {{FUNCTION_PREFIX}}_SetOutputRamp({{STRUCT_NAME}} *pid, {{DATA_TYPE}} rate);

/**
 * @brief Sets the error deadband. Errors within +/- deadband_val/2 are treated as zero.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     deadband_val The deadband width.
 */
void {{FUNCTION_PREFIX}}_SetDeadband({{STRUCT_NAME}} *pid, {{DATA_TYPE}} deadband_val);

/**
 * @brief Sets the integral separation threshold. Integral action is only active if abs(error) < threshold.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     threshold The error threshold.
 */
void {{FUNCTION_PREFIX}}_SetIntegralSeparationThreshold({{STRUCT_NAME}} *pid, {{DATA_TYPE}} threshold);

/**
 * @brief Sets the low-pass filter coefficient for the derivative term.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     filter_coef Filter coefficient (0.0 to 1.0). 0 means no filtering.
 * A smaller value means more filtering. (e.g. 0.1 for significant filtering)
 */
void {{FUNCTION_PREFIX}}_SetDFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef);

/**
 * @brief Sets the low-pass filter coefficient for the measurement input.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     filter_coef Filter coefficient (0.0 to 1.0). 0 means no filtering.
 */
void {{FUNCTION_PREFIX}}_SetInputFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef);

/**
 * @brief Sets the low-pass filter coefficient for the setpoint.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     filter_coef Filter coefficient (0.0 to 1.0). 0 means no filtering.
 */
void {{FUNCTION_PREFIX}}_SetSetpointFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef);

/**
 * @brief Sets the operational mode of the PID controller.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     mode The new mode to set (@see PID_ModeType).
 */
void {{FUNCTION_PREFIX}}_SetMode({{STRUCT_NAME}} *pid, PID_ModeType mode);

/**
 * @brief Sets the calculation type of the PID controller.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     type The new PID type to set (@see PID_Type).
 */
void {{FUNCTION_PREFIX}}_SetType({{STRUCT_NAME}} *pid, PID_Type type);

/**
 * @brief Sets the work mode (output nature) of the PID controller.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     work_mode The new work mode to set (@see PID_WorkMode).
 */
void {{FUNCTION_PREFIX}}_SetWorkMode({{STRUCT_NAME}} *pid, PID_WorkMode work_mode);

/**
 * @brief Computes the PID output based on the current setpoint and measurement.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     setpoint The desired target value.
 * @param[in]     measure The current process value (measurement).
 * @return        The calculated PID controller output.
 * @note          This function uses the `sample_time` member fixed within the PID struct.
 * Call this function at regular intervals matching `sample_time`.
 */
{{DATA_TYPE}} {{FUNCTION_PREFIX}}_Compute({{STRUCT_NAME}} *pid, {{DATA_TYPE}} setpoint, {{DATA_TYPE}} measure);

/**
 * @brief Computes the PID output with a dynamically provided current time.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     setpoint The desired target value.
 * @param[in]     measure The current process value.
 * @param[in]     current_time_ms Current system time in milliseconds.
 * @return        The calculated PID controller output.
 * @note          This function calculates the delta_time since the last call and adjusts
 * the internal sample_time for this computation cycle. Useful if call interval varies.
 */
{{DATA_TYPE}} {{FUNCTION_PREFIX}}_ComputeWithTime({{STRUCT_NAME}} *pid, {{DATA_TYPE}} setpoint, {{DATA_TYPE}} measure, uint32_t current_time_ms);

/**
 * @brief Resets the PID controller's internal state variables (integral, previous values).
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @note          Does not reset tuning parameters or configuration.
 */
void {{FUNCTION_PREFIX}}_Reset({{STRUCT_NAME}} *pid);

/**
 * @brief Allows manually setting the PID output value.
 * @param[in,out] pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[in]     output_val The desired output value.
 * @note          This function is typically used when the controller is in PID_MODE_MANUAL.
 * The output will be clamped by the configured output limits.
 */
void {{FUNCTION_PREFIX}}_SetOutput({{STRUCT_NAME}} *pid, {{DATA_TYPE}} output_val);

/**
 * @brief Retrieves the last computed P, I, D, and FF term components.
 * @param[in]  pid Pointer to the {{STRUCT_NAME}} instance.
 * @param[out] p_term Pointer to store the last proportional term. Can be NULL.
 * @param[out] i_term Pointer to store the current integral term. Can be NULL.
 * @param[out] d_term Pointer to store the last filtered derivative term. Can be NULL.
 * @param[out] ff_term Pointer to store the last feedforward term. Can be NULL.
 * @note       Useful for debugging and understanding controller behavior.
 */
void {{FUNCTION_PREFIX}}_GetComponents({{STRUCT_NAME}} *pid, {{DATA_TYPE}} *p_term, {{DATA_TYPE}} *i_term, {{DATA_TYPE}} *d_term, {{DATA_TYPE}} *ff_term);

#endif /* __PID_H_ADVANCED_TEMPLATE__ */