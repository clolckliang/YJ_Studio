/**
 * @file    {{FUNCTION_PREFIX}}_pid.c
 * @author  YJ Studio Team (Generated by Advanced PID Code Generator)
 * @version 2.3.0
 * @date    {{TIMESTAMP}}
 * @brief   Fully-Featured Advanced PID Controller Library Implementation File.
 */

#include "{{HEADER_NAME}}"
#include <math.h>
#include <stddef.h>

#ifdef __cplusplus
#define SFX_F {{SFX}}
#else
#define SFX_F {{SFX}}
#endif

#ifndef INFINITY
    #define INFINITY (1.0f/0.0f)
#endif

static inline {{DATA_TYPE}} constrain_pid_output({{DATA_TYPE}} value, {{DATA_TYPE}} min_val, {{DATA_TYPE}} max_val) {
    if (value < min_val) return min_val;
    if (value > max_val) return max_val;
    return value;
}

void {{FUNCTION_PREFIX}}_Init({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kp_continuous, {{DATA_TYPE}} Ki_continuous, {{DATA_TYPE}} Kd_continuous, {{DATA_TYPE}} sample_time_val) {
    if (pid == NULL) return;
    {{FUNCTION_PREFIX}}_Reset(pid);
    {{FUNCTION_PREFIX}}_SetTunings(pid, Kp_continuous, Ki_continuous, Kd_continuous);
    pid->sample_time = (sample_time_val > 0.000001{{SFX}}) ? sample_time_val : 0.01{{SFX}};
    pid->Kff = {{KFF_DEFAULT}};
    pid->ff_weight = {{FF_WEIGHT_DEFAULT}};
    pid->output_limit = {{OUTPUT_LIMIT_DEFAULT}};
    pid->integral_limit = {{INTEGRAL_LIMIT_DEFAULT}};
    pid->output_ramp = {{OUTPUT_RAMP_DEFAULT}};
    pid->deadband = {{DEADBAND_DEFAULT}};
    pid->integral_separation_threshold = {{INTEGRAL_SEPARATION_THRESHOLD_DEFAULT}};
    pid->d_filter_coef = {{D_FILTER_COEF_DEFAULT}};
    pid->input_filter_coef = {{INPUT_FILTER_COEF_DEFAULT}};
    pid->setpoint_filter_coef = {{SETPOINT_FILTER_COEF_DEFAULT}};
    pid->adaptive_enable = {{ADAPTIVE_ENABLE}};
    pid->fuzzy_enable = {{FUZZY_ENABLE}};
    pid->mode = PID_MODE_AUTOMATIC;
    pid->type = PID_TYPE_STANDARD;
    pid->work_mode = PID_MODE_POSITION;
}

void {{FUNCTION_PREFIX}}_SetTunings({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kp_continuous, {{DATA_TYPE}} Ki_continuous, {{DATA_TYPE}} Kd_continuous) {
    if (pid == NULL || Kp_continuous < 0.0f || Ki_continuous < 0.0f || Kd_continuous < 0.0f) return;
    pid->Kp = Kp_continuous;
    if (pid->sample_time > 0.000001{{SFX}}) {
        pid->Ki = Ki_continuous * pid->sample_time;
        pid->Kd = Kd_continuous / pid->sample_time;
    }
}

void {{FUNCTION_PREFIX}}_SetFeedForwardParams({{STRUCT_NAME}} *pid, {{DATA_TYPE}} Kff, {{DATA_TYPE}} ff_weight) {
    if (pid == NULL) return;
    pid->Kff = Kff;
    pid->ff_weight = constrain_pid_output(ff_weight, 0.0f, 1.0f);
}

void {{FUNCTION_PREFIX}}_SetSampleTime({{STRUCT_NAME}} *pid, {{DATA_TYPE}} sample_time_new) {
    if (pid == NULL || sample_time_new <= 0.000001f) return;
    if (pid->sample_time > 0.000001f) {
        {{DATA_TYPE}} ratio = sample_time_new / pid->sample_time;
        pid->Ki *= ratio;
        pid->Kd /= ratio;
    }
    pid->sample_time = sample_time_new;
}

void {{FUNCTION_PREFIX}}_SetOutputLimits({{STRUCT_NAME}} *pid, {{DATA_TYPE}} limit) {
    if (pid == NULL) return;
    pid->output_limit = fabsf(limit);
}

void {{FUNCTION_PREFIX}}_SetIntegralLimits({{STRUCT_NAME}} *pid, {{DATA_TYPE}} limit) {
    if (pid == NULL) return;
    pid->integral_limit = fabsf(limit);
}

void {{FUNCTION_PREFIX}}_SetOutputRamp({{STRUCT_NAME}} *pid, {{DATA_TYPE}} rate) {
    if (pid == NULL) return;
    pid->output_ramp = fabsf(rate);
}

void {{FUNCTION_PREFIX}}_SetDeadband({{STRUCT_NAME}} *pid, {{DATA_TYPE}} deadband_val) {
    if (pid == NULL) return;
    pid->deadband = fabsf(deadband_val);
}

void {{FUNCTION_PREFIX}}_SetIntegralSeparationThreshold({{STRUCT_NAME}} *pid, {{DATA_TYPE}} threshold) {
    if (pid == NULL) return;
    pid->integral_separation_threshold = fabsf(threshold);
}

void {{FUNCTION_PREFIX}}_SetDFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef) {
    if (pid == NULL) return;
    pid->d_filter_coef = constrain_pid_output(filter_coef, 0.0f, 1.0f);
}

void {{FUNCTION_PREFIX}}_SetInputFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef) {
    if (pid == NULL) return;
    pid->input_filter_coef = constrain_pid_output(filter_coef, 0.0f, 1.0f);
}

void {{FUNCTION_PREFIX}}_SetSetpointFilter({{STRUCT_NAME}} *pid, {{DATA_TYPE}} filter_coef) {
    if (pid == NULL) return;
    pid->setpoint_filter_coef = constrain_pid_output(filter_coef, 0.0f, 1.0f);
}

void {{FUNCTION_PREFIX}}_SetMode({{STRUCT_NAME}} *pid, PID_ModeType mode) {
    if (pid == NULL) return;
    if (pid->mode != mode && mode == PID_MODE_AUTOMATIC) {
        pid->integral = constrain_pid_output(pid->prev_output, -pid->integral_limit, pid->integral_limit);
    }
    pid->mode = mode;
}

void {{FUNCTION_PREFIX}}_SetType({{STRUCT_NAME}} *pid, PID_Type type) {
    if (pid != NULL) pid->type = type;
}

void {{FUNCTION_PREFIX}}_SetWorkMode({{STRUCT_NAME}} *pid, PID_WorkMode work_mode) {
    if (pid != NULL) pid->work_mode = work_mode;
}

{{DATA_TYPE}} {{FUNCTION_PREFIX}}_Compute({{STRUCT_NAME}} *pid, {{DATA_TYPE}} setpoint, {{DATA_TYPE}} measure) {
    if (pid == NULL || pid->sample_time <= 0.000001{{SFX}}) {
        return (pid != NULL) ? pid->output : 0.0{{SFX}};
    }
    if (pid->mode == PID_MODE_MANUAL) return pid->output;

    if (pid->input_filter_coef > 0.0f) {
        measure = pid->filtered_measure * (1.0f - pid->input_filter_coef) + measure * pid->input_filter_coef;
    }
    pid->filtered_measure = measure;

    if (pid->setpoint_filter_coef > 0.0f) {
        setpoint = pid->filtered_setpoint * (1.0f - pid->setpoint_filter_coef) + setpoint * pid->setpoint_filter_coef;
    }
    pid->filtered_setpoint = setpoint;

    {{DATA_TYPE}} error = setpoint - measure;
    if (pid->deadband > 0.0f && fabsf(error) < pid->deadband) error = 0.0f;
    
    pid->last_p_term = (pid->type == PID_TYPE_I_PD) ? -pid->Kp * measure : pid->Kp * error;
    
    if (fabsf(error) < pid->integral_separation_threshold) {
        pid->integral += pid->Ki * error;
        pid->integral = constrain_pid_output(pid->integral, -pid->integral_limit, pid->integral_limit);
    }
    pid->last_i_term = pid->integral;

    {{DATA_TYPE}} d_input = (pid->type == PID_TYPE_STANDARD) ? (error - pid->prev_error) : -(measure - pid->prev_measure);
    d_input /= pid->sample_time;
    if (pid->d_filter_coef > 0.0f) {
        d_input = pid->filtered_d * (1.0f - pid->d_filter_coef) + d_input * pid->d_filter_coef;
    }
    pid->filtered_d = d_input;
    pid->last_d_term = pid->Kd * pid->filtered_d;
    
    pid->last_ff_term = pid->Kff * setpoint * pid->ff_weight;
    
    {{DATA_TYPE}} computed_output = pid->last_p_term + pid->last_i_term + pid->last_d_term + pid->last_ff_term;

    if (pid->output_ramp > 0.0f) {
        {{DATA_TYPE}} max_change = pid->output_ramp * pid->sample_time;
        computed_output = pid->prev_output + constrain_pid_output(computed_output - pid->prev_output, -max_change, max_change);
    }
    
    computed_output = constrain_pid_output(computed_output, -pid->output_limit, pid->output_limit);
    
    pid->prev_error = error;
    pid->prev_measure = measure;
    
    pid->output = (pid->work_mode == PID_MODE_VELOCITY) ? (computed_output - pid->prev_output) : computed_output;
    pid->prev_output = computed_output;
    
    return pid->output;
}

{{DATA_TYPE}} {{FUNCTION_PREFIX}}_ComputeWithTime({{STRUCT_NAME}} *pid, {{DATA_TYPE}} setpoint, {{DATA_TYPE}} measure, uint32_t current_time_ms) {
    if (pid == NULL) return 0.0f;
    if (pid->last_time == 0) pid->last_time = current_time_ms;
    
    uint32_t dt_ms = current_time_ms - pid->last_time;
    if (dt_ms == 0) return pid->output;
    
    {{DATA_TYPE}} dt_s = ({{DATA_TYPE}})dt_ms / 1000.0f;
    {{DATA_TYPE}} original_sample_time = pid->sample_time;
    {{FUNCTION_PREFIX}}_SetSampleTime(pid, dt_s);
    
    {{DATA_TYPE}} result = {{FUNCTION_PREFIX}}_Compute(pid, setpoint, measure);
    
    {{FUNCTION_PREFIX}}_SetSampleTime(pid, original_sample_time);
    pid->last_time = current_time_ms;
    
    return result;
}

void {{FUNCTION_PREFIX}}_Reset({{STRUCT_NAME}} *pid) {
    if (pid == NULL) return;
    *pid = ({{STRUCT_NAME}}){ .Kp = pid->Kp, .Ki = pid->Ki, .Kd = pid->Kd }; // Keep gains, reset rest
}

void {{FUNCTION_PREFIX}}_SetOutput({{STRUCT_NAME}} *pid, {{DATA_TYPE}} output_val) {
    if (pid != NULL && pid->mode == PID_MODE_MANUAL) {
        pid->output = constrain_pid_output(output_val, -pid->output_limit, pid->output_limit);
        pid->prev_output = pid->output;
    }
}

void {{FUNCTION_PREFIX}}_GetComponents({{STRUCT_NAME}} *pid, {{DATA_TYPE}} *p_term, {{DATA_TYPE}} *i_term, {{DATA_TYPE}} *d_term, {{DATA_TYPE}} *ff_term) {
    if (pid == NULL) return;
    if (p_term != NULL) *p_term = pid->last_p_term;
    if (i_term != NULL) *i_term = pid->last_i_term;
    if (d_term != NULL) *d_term = pid->last_d_term;
    if (ff_term != NULL) *ff_term = pid->last_ff_term;
}
